


1、抽象方法 、抽象类  接口


2、final修饰符号


	类

	方法
	
	属性
	变量

3、访问权限

	四个符号的 访问权限

			其它包  public 

			本包和其它包的亲戚；protected 

			本包  没有;

			本类；private


	

4、类的权限

			public class XX{}


5、内部类  匿名内内部

			class A{

				class B{}

			}


			方便 内部类 访问外部类中的 属性方法；

			一般情况下，内部类都是  一次性使用的类；


6、多线程

			两种方法实现多线程

					继承式；(extends Thread)

					实现式；(implements Runnable)



7、异常处理


			

			异常，是程序在执行的过程中发生的异常事件；


				语法错误都是在编译的时候发生；

				异常能否避免？

				异常属于  程序员 无力控制的 各种事件；


				C语言对待 异常 的态度就是 直接结束程序，报错；


			程序越大，越需要考虑处理各种 异常，让用户有好的使用体验；


		异常处理的意义在于：让用户使用到我们的 软件的时候 不感到害怕，或者莫名其妙；




		java是如何设计异常处理机制的。



		它将各种各样的  异常  都  创建对应的类，如果 程序在执行的过程中发生该异常，则 系统用 相应的类


		创建相应的对象   ，扔给 程序，让程序处理。


		所以：异常处理 的本质 是 系统 扔 给我们一个  对象  ，让 我们处理。




		异常处理的套路：


				方法1：(勤快模式)

					try{

						可能发生异常的代码；

					}

					catch(异常类型 e){



						处理代码

					}


					模式;

				

			

					形式1：

					try{.....}

					catch(异常类型){}


					
					

					形式2：

					try{.....}

					catch(异常类型1 e1){}
					catch(异常类型2 e2){}
					catch(异常类型3 e3){}
					....
			
			
		          		

					形式2：

					try{.....}

					catch(异常类型1 e1){   }
					catch(异常类型2 e2){   }
					catch(异常类型3 e3){   }
					....

					finnally{

						不管发生什么，该代码 都会被执行；

						异常情况例外：

								catch中如果有Syetem.exit(0);

					}





		处理方法2:（笨蛋模式)


					我不会或者不愿意处理，则

					在异常可能发生的代码

					所在的方法后



					throws 异常类型；


				这也是一种处理异常的方式，   该方式寓意：谁调用，谁处理；



			
			这就是为什么，我们有时候调用系统的各种  方法的时候，需要异常处理；



		实际开发中：


			 大部分情况下，我们的异常都是 自己处理，而不是抛给别人处理；try{}catch(){}


			如果你的类，不是项目类，是一个开发出来 公用的 开发类，则考虑 抛出异常，让别人处理；





		一个万能的  异常处理的方法

				就是在main()后throws Exception

		
		因为：异常类的根类 就是Exception类；


		这个经验在项目开发的前期，为了快速的实现功能，避免在异常处理上占用精力，就这么做；


		

		真实的开发：   项目越贵，异常处理越细致，越严谨、越分类清楚；


		商业项目的代码：一般是，

					1:                10  

					业务代码    异常处理代码；





		万能处理2

					try{

					所有代码;

					}catch(Exception ex){


						System.out.println("不好意思，软件升级中...");

					}




















